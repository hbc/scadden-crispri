# Background
This project is to look at comparing pre vs post-transplantion in two cell
lines with two different versions of the Gecko library (A and B). The goal is
to look for genes depleted across both versions of the Gecko library and both
cell lines.

We were given tables of counts and the FASTQ files. For a first analysis
we'll just use the table of counts.

# Data prep
Rather than remapping the data we'll start from the count files already
generated and see what we can do with them. First we will load in the
count files and do some sanity checking to make sure the data is what
we are expecting it to be.

```{r filenames}
a_post_fn = "../data/library-a-post-transplant-counts.csv"
b_post_fn = "../data/library-b-post-transplant-counts.csv"
a_gecko_fn = "../data/library-a-sequences-and-genes.csv"
b_gecko_fn = "../data/library-b-sequences-and-genes.csv"
a_pre_fn = "../data/pre-la.csv"
b_pre_fn = "../data/pre-lb.csv"
a_new_fn = "../data/new-library-a-counts.csv"
b_new_fn = "../data/new-library-b-counts.csv"
```

```{r libraries}
library(readr)
library(tidyr)
library(dplyr)
```

The post transplant count file has an extra row called 'Total', we will drop that.
We'll also drop any rows from the Gecko files that don't appear in the
pre/post transplant count files. We'll drop the extraneous `ID`, `Sequence`
and `Plate` columns from the pre transplant count file.
We'll make a matrix of the counts such that the row names are the UIDs.
Finally we construct a dataframe that has the information we need about
each sample regarding what cell line it is from, which Gecko library was
used to treat it and whether or not it was a transplanted or non transplanted
sample.

```{r cleanup-count-files-functions}
cleanup_counts = function(fn) {
   exclude_columns = c("ID", "Sequences", "Plate", "UID")
   counts = readr::read_csv(fn, col_names=TRUE)
   colnames(counts)[1] = "UID"
   counts = data.frame(subset(counts, UID != "Total"))
   rownames(counts) = counts$UID
   counts = counts[, !colnames(counts) %in% exclude_columns]
   return(counts)
}

cleanup_gecko = function(fn, valid) {
   gecko = readr::read_csv(fn, col_names=TRUE)
   gecko = data.frame(subset(gecko, UID %in% valid))
   rownames(gecko) = gecko$UID
   gecko$UID = NULL
   return(gecko)
}

combine_pre_post = function(pre, post, library) {
   return(cbind(pre, post))
}

derive_sample_data = function(pre, post) {
   pre_df = data.frame(sample=colnames(pre), transplant="pre")
   post_df = data.frame(sample=colnames(post), transplant="post")
   pre_df$line = ifelse(grepl("^HM", colnames(pre)), "HM",
                   ifelse(grepl("^MLLAF9", colnames(pre)), "MLLAF9", NA))
   post_df$line = ifelse(grepl("^H", colnames(post)), "HM",
                   ifelse(grepl("^M", colnames(post)), "MLLAF9", NA))
   pre_df$library = "pre"
   post_df$library = ifelse(grepl("^.A", colnames(post)), "A",
                       ifelse(grepl("^.B", colnames(post)), "B", NA))
   combined = rbind(pre_df, post_df)
   rownames(combined) = combined$sample
   combined$sample = NULL
   return(combined)}
```

```{r load-a}
a_pre = cleanup_counts(a_pre_fn)
a_post = cleanup_counts(a_post_fn)
a_counts = combine_pre_post(a_pre, a_post)
a_gecko = cleanup_gecko(a_gecko_fn, rownames(a_counts))
a_sample = derive_sample_data(a_pre, a_post)
a_sample = a_sample[colnames(a_counts),]
```

```{r load-b}
b_pre = cleanup_counts(b_pre_fn)
b_post = cleanup_counts(b_post_fn)
b_counts = combine_pre_post(b_pre, b_post)
b_gecko = cleanup_gecko(b_gecko_fn, rownames(b_counts))
b_sample = derive_sample_data(b_pre, b_post)
b_sample = b_sample[colnames(b_counts),]
```

They want to look for genes that are depleted, not the UIDs. The UIDs are
not the same across library B and library A, so we need to somehow account
for that. We could do something simple like just look at the UIDs that
are different in each library and then see which genes are in common across
the two libraries. We will do this first, and then get more complex later.

First we'll do some quality control of the samples.

## Quality Control
### Library A
